#!/usr/bin/env bash
# Helper for managing per-worktree Cuttlefish instances on the Hetzner host.
# Mirrors the emulator tooling that records per-worktree state, but drives
# the systemd template service (`cuttlefish@<instance>`).

set -euo pipefail

REMOTE_HOST="${CUTTLEFISH_REMOTE_HOST:-hetzner}"
REMOTE_HOME_CACHE=""
HOST_SHORT="$(hostname 2>/dev/null || echo "")"
HOST_FQDN="$(hostname -f 2>/dev/null || echo "")"

is_local_host() {
  case "${REMOTE_HOST}" in
    ""|"local"|"localhost"|"127.0.0.1"|"$HOST_SHORT"|"$HOST_FQDN") return 0 ;;
    *) return 1 ;;
  esac
}

remote_shell() {
  local script="$1"
  if is_local_host; then
    bash -lc "$script"
  else
    ssh "$REMOTE_HOST" "bash -lc $(printf '%q' "$script")"
  fi
}

die() {
  echo "cuttlefish_instance: $*" >&2
  exit 1
}

repo_root() {
  git rev-parse --show-toplevel 2>/dev/null || die "must run inside the repo"
}

worktree_basename() {
  local root
  root="$(repo_root)"
  if [[ "$root" == *"/worktrees/"* ]]; then
    basename "$root"
  else
    git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main"
  fi
}

cuttlefish_instance_name() {
  local raw="$1"
  if [[ "$raw" =~ ^[0-9]+$ ]]; then
    printf '%s' "$raw"
    return
  fi
  if [[ -z "$raw" ]]; then
    raw="$(worktree_basename)"
  fi
  [[ -z "$raw" ]] && raw="main"
  raw="${raw,,}"
  raw="${raw//[^a-z0-9-]/-}"
  raw="${raw#-}"
  raw="${raw%-}"
  [[ -z "$raw" ]] && raw="main"
  local checksum
  checksum="$(printf '%s' "$raw" | cksum | awk '{print $1}')"
  printf '%s' "${checksum:-0}"
}

instance_name() {
  CUTTLEFISH_INSTANCE_EFFECTIVE="$(cuttlefish_instance_name "${CUTTLEFISH_INSTANCE_OVERRIDE:-}")"
  printf '%s\n' "$CUTTLEFISH_INSTANCE_EFFECTIVE"
}

remote_home() {
  if [[ -z "${REMOTE_HOME_CACHE:-}" ]]; then
    if is_local_host; then
      REMOTE_HOME_CACHE="$HOME"
    else
    if is_local_host; then
      REMOTE_HOME_CACHE="$HOME"
    else
      REMOTE_HOME_CACHE="$(remote_shell 'printf %s "$HOME"')"
    fi
    fi
  fi
  printf '%s' "$REMOTE_HOME_CACHE"
}

remote_instance_root() {
  local base="${CUTTLEFISH_REMOTE_BASE:-}"
  if [[ -n "$base" ]]; then
    if [[ "$base" == /* ]]; then
      printf '%s' "$base"
    else
      printf '%s/%s' "$(remote_home)" "$base"
    fi
  else
    printf '%s/cuttlefish-instances' "$(remote_home)"
  fi
}

remote_instance_dir() {
  printf '%s/%s' "$(remote_instance_root)" "$INSTANCE"
}

copy_to_remote() {
  local src="$1"
  local dest="$2"
  if is_local_host; then
    mkdir -p "$(dirname "$dest")"
    cp "$src" "$dest"
  else
    scp -q "$src" "${REMOTE_HOST}:$dest"
  fi
}

record_instance() {
  local inst="$1"
  local root
  root="$(repo_root)"
  printf '%s\n' "$inst" > "${root}/.cuttlefish-instance"
}

remote_sudo() {
  local cmd="$1"
  if is_local_host; then
    sudo bash -lc "$cmd"
  else
    ssh "$REMOTE_HOST" "sudo bash -lc $(printf '%q' "$cmd")"
  fi
}

wait_unit_active() {
  local timeout="${1:-60}"
  local unit="cuttlefish@${INSTANCE}"
  remote_sudo "$(cat <<EOF
set -euo pipefail
unit="$unit"
deadline=\$(( \$(date +%s) + $timeout ))
while true; do
  state=\$(systemctl show -p ActiveState --value "\$unit" 2>/dev/null || echo "unknown")
  case "\$state" in
    active) exit 0 ;;
    failed) exit 1 ;;
  esac
  if (( \$(date +%s) >= deadline )); then
    exit 2
  fi
  sleep 1
done
EOF
)"
  return $?
}

remote_raw() {
  if is_local_host; then
    "$@"
  else
    ssh "$REMOTE_HOST" "$@"
  fi
}

ensure_envdir() {
  remote_sudo "install -d -m 0755 /etc/cuttlefish/instances"
}

write_env_file() {
  local inst="$1"
  local boot="$2"
  local init="$3"
  ensure_envdir
  remote_sudo "systemctl unset-environment CUTTLEFISH_BOOT_IMAGE CUTTLEFISH_INIT_BOOT_IMAGE" || true
  local tmp
  tmp="$(mktemp)"
  {
    echo "# Autogenerated by scripts/cuttlefish_instance.sh ($(date -u +'%Y-%m-%dT%H:%M:%SZ'))"
    if [[ -z "$boot" && -z "$init" ]]; then
      printf 'CUTTLEFISH_BOOT_IMAGE=%s\n' "/var/lib/cuttlefish/images/boot.img"
      printf 'CUTTLEFISH_INIT_BOOT_IMAGE=%s\n' "/var/lib/cuttlefish/images/init_boot.img"
    else
      [[ -n "$boot" ]] && printf 'CUTTLEFISH_BOOT_IMAGE=%s\n' "$boot"
      [[ -n "$init" ]] && printf 'CUTTLEFISH_INIT_BOOT_IMAGE=%s\n' "$init"
    fi
  } >"$tmp"
  if is_local_host; then
    local temp_path="/tmp/${inst}.env"
    install -m 0640 "$tmp" "$temp_path"
    remote_sudo "install -m 0640 $temp_path /etc/cuttlefish/instances/${inst}.env && rm -f $temp_path"
  else
    scp -q "$tmp" "${REMOTE_HOST}:/tmp/${inst}.env"
    remote_sudo "install -m 0640 /tmp/${inst}.env /etc/cuttlefish/instances/${inst}.env && rm -f /tmp/${inst}.env"
  fi
  rm -f "$tmp"
}

current_env_value() {
  local key="$1"
  local env_path="/etc/cuttlefish/instances/${INSTANCE}.env"
  local env_escaped
  env_escaped="$(printf '%q' "$env_path")"
  local script="
set -euo pipefail
if [ -f ${env_escaped} ]; then
  . ${env_escaped}
fi
printf '%s' \"\${${key}:-}\"
"
  remote_shell "$script"
}

show_usage() {
  cat <<'EOF'
Usage: scripts/cuttlefish_instance.sh <command> [options]

Commands:
  instance-name                Print the deterministic instance name and record it locally.
  set-env [--boot PATH] [--init-boot PATH]
                               Write the per-instance environment file on the server.
                               Omit both flags to clear the file.
  start|stop|restart           Manage the cuttlefish@<instance> service.
  status                       Show systemd status for the instance.
  logs [--follow]              Tail journal logs for the instance.
  console-log [--follow]       Tail the guest console log for the instance.
  env                          Print the current environment file (if any).
  deploy [--init PATH] [--boot PATH]
                               Copy local images to the per-instance workspace
                               on the remote host and update the environment.

Environment:
  CUTTLEFISH_INSTANCE_OVERRIDE  Override the computed instance name.
  CUTTLEFISH_REMOTE_HOST        SSH host alias (default: hetzner).
  CUTTLEFISH_REMOTE_BASE        Remote directory for artifacts (default:
                                ~/cuttlefish-instances).
EOF
}

COMMAND="${1:-}"
if [[ -z "$COMMAND" ]]; then
  show_usage
  exit 1
fi
shift

INSTANCE="$(instance_name)"
record_instance "$INSTANCE"

case "$COMMAND" in
  instance-name)
    echo "$INSTANCE"
    ;;
  set-env)
    boot=""
    init=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --boot)
          boot="${2:?missing value for --boot}"
          shift 2
          ;;
        --init-boot)
          init="${2:?missing value for --init-boot}"
          shift 2
          ;;
        --clear)
          boot=""
          init=""
          shift
          ;;
        *)
          die "unknown flag for set-env: $1"
          ;;
      esac
    done
    write_env_file "$INSTANCE" "$boot" "$init"
    echo "Updated /etc/cuttlefish/instances/${INSTANCE}.env on ${REMOTE_HOST}"
    ;;
  start)
    remote_sudo "systemctl start cuttlefish@${INSTANCE}"
    if ! wait_unit_active 60; then
      echo "cuttlefish@${INSTANCE} failed to start" >&2
      remote_raw sudo journalctl -u "cuttlefish@${INSTANCE}" -n 200 >&2 || true
      exit 1
    fi
    ;;
  restart)
    remote_sudo "systemctl restart cuttlefish@${INSTANCE}"
    if ! wait_unit_active 60; then
      echo "cuttlefish@${INSTANCE} failed to restart" >&2
      remote_raw sudo journalctl -u "cuttlefish@${INSTANCE}" -n 200 >&2 || true
      exit 1
    fi
    ;;
  stop)
    remote_sudo "systemctl stop cuttlefish@${INSTANCE}"
    ;;
  status)
    remote_sudo "systemctl status cuttlefish@${INSTANCE}"
    ;;
  logs)
    follow_flag=""
    if [[ "${1:-}" == "--follow" ]]; then
      follow_flag="-f"
      shift
    fi
    remote_raw journalctl -u "cuttlefish@${INSTANCE}" -n 200 $follow_flag
    ;;
  console-log)
    follow_flag=""
    if [[ "${1:-}" == "--follow" ]]; then
      follow_flag="-f"
      shift
    fi
    remote_raw bash -lc "$(printf 'tail %s /var/lib/cuttlefish/instances/%s/instances/%s/console_log' "$follow_flag" "$INSTANCE" "$INSTANCE")"
    ;;
  env)
    remote_raw sudo cat "/etc/cuttlefish/instances/${INSTANCE}.env" 2>/dev/null || {
      echo "(no env file for ${INSTANCE})"
    }
    ;;
  deploy)
    init_path=""
    boot_path=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --init)
          init_path="${2:?missing value for --init}"
          shift 2
          ;;
        --boot)
          boot_path="${2:?missing value for --boot}"
          shift 2
          ;;
        *)
          die "unknown flag for deploy: $1"
          ;;
      esac
    done
    if [[ -z "$init_path" && -z "$boot_path" ]]; then
      die "deploy requires --init and/or --boot"
    fi
    remote_dir="$(remote_instance_dir)"
    remote_shell "set -eu; mkdir -p $(printf '%q' "$remote_dir")"
    init_remote=""
    boot_remote=""
    if [[ -n "$init_path" ]]; then
      [[ -f "$init_path" ]] || die "init image not found: $init_path"
      init_remote="${remote_dir}/init_boot.img"
      copy_to_remote "$init_path" "$init_remote"
    fi
    if [[ -n "$boot_path" ]]; then
      [[ -f "$boot_path" ]] || die "boot image not found: $boot_path"
      boot_remote="${remote_dir}/boot.img"
      copy_to_remote "$boot_path" "$boot_remote"
    fi
    current_boot="$(current_env_value CUTTLEFISH_BOOT_IMAGE)"
    current_init="$(current_env_value CUTTLEFISH_INIT_BOOT_IMAGE)"
    if [[ -z "$boot_remote" ]]; then
      boot_remote="$current_boot"
    fi
    if [[ -z "$init_remote" ]]; then
      init_remote="$current_init"
    fi
    write_env_file "$INSTANCE" "$boot_remote" "$init_remote"
    echo "Synced artifacts to ${remote_dir}"
    if [[ -n "$boot_remote" ]]; then
      echo "  CUTTLEFISH_BOOT_IMAGE=${boot_remote}"
    fi
    if [[ -n "$init_remote" ]]; then
      echo "  CUTTLEFISH_INIT_BOOT_IMAGE=${init_remote}"
    fi
    ;;
  *)
    show_usage
    die "unknown command: $COMMAND"
    ;;
esac
